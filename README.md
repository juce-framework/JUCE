# JUCE_ARA

This repository is a fork of the [JUCE 5 develop branch](https://github.com/WeAreROLI/JUCE) with additions that enable it to generate [ARA plugins](https://www.celemony.com/en/service1/about-celemony/technologies) in the VST3 or AudioUnit format.
The fork is currently being maintained by [Celemony](https://www.celemony.com) and [SoundRadix](https://www.soundradix.com), with the goal of it being picked up eventually by [ROLI](https://www.juce.com) for main line JUCE.

In order to use this branch you'll need access to the [ARA SDK](http://www.celemony.com/en/service1/about-celemony/technologies) - if you're a developer and would like access to the latest ARA SDK release, send an email to [ara@celemony.com](mailto:ara@celemony.com?Subject=JUCE%20ARA%20integration).

Current ARA SDK compatibility version: 1.9.6.020

For feedback and questions, please contact Celemony via [ara@celemony.com](mailto:ara@celemony.com?Subject=JUCE%20ARA%20integration).

### Getting started:

We've made modifications to the Projucer to enable it to work with the ARA 2.0 SDK. These modifications allow building VST3 and AudioUnit plugins that can be loaded as ARA plugins by a compatible host. 

To create an ARA plugin, clone the develop branch of Celemony's [JUCE fork](https://github.com/Celemony/JUCE_ARA/tree/develop) build the [Projucer](https://github.com/Celemony/JUCE_ARA/tree/develop/extras/Projucer)(projects for Visual Studio and Xcode are checked in to the repository.)

Once you have the ARA version of the Projucer built you can use it to specify your global ARA path like so:

<img src="https://i.imgur.com/fRjU8kB.png"/>

This ARA SDK path will be used for new ARA plugin projects, but can also be configured per project.

Once the SDK has been located we can create a new Audio Plug-In project like so

<img src="https://i.imgur.com/cqsEA18.png"/>

We specifically want to create an ARA plugin. This is not one of the main types in the template window but can be selected like so:

<img src="https://i.imgur.com/mY6Z1XL.png"/>

If you've already got a JUCE audio plugin project, you can enable ARA in our version of the Projucer using the "Enable ARA" checkbox. 
However, you'll have to add your own document controller implementation - referencing the autogenerated ARA Audio Plug-In project is a good starting point for enabling ARA in existing plugins. 

<img src="https://i.imgur.com/dq9F1X8.png"/>

The generated plugin will have, in addition to the standard PluginProcessor and PluginEditor classes, a PluginARADocumentController file containing a class that overrides the ARA::PlugIn::DocumentController type.

<img src="https://i.imgur.com/JqNIe2b.png"/>

This version of the Projucer supports VST3 and AudioUnit, so make sure at least one of these plugin formats is checked
<img src="https://i.imgur.com/7wWWPuK.png"/>

We can also edit other ARA plugin factory properties such as available content types and transformation flags as well as the plugin factory identifier.

With ARA enabled we can edit various ARA factory properties plugin factory properties such as available content types and transformation flags as well as the plugin factory identifier.

<img src="https://i.imgur.com/mJoXIxG.png"/>

This should be enough to generate an empty ARA plugin that will appear in an ARA host, such as Studio One or SONAR. For a more complete example of an ARA plugin see the [ARA Sample Project](https://github.com/Celemony/JUCE_ARA/tree/develop/examples/ARA/ARASampleProject) checked in to this repository. 

### JUCE and the ARA API

<br>
#### ARADocumentController

As is the case in the ARA C++ library, the `juce::ARADocumentController` class must be subclassed by your
ARA plugin. The ARA host will use your document controller to build a representation of the ARA document for
your plugin - by default the `juce::ARADocumentController` will create the classes outlined below, but your plugin should override the `doCreate` functions in order to create objects that suit your purpose. 

In the 
[ARA Sample Project DocumentController class](https://github.com/Celemony/JUCE_ARA/tree/develop/examples/ARA/ARASampleProject/Source/ARASampleProjectDocumentController.h)
we override `doCreatePlaybackRenderer` in order to return a custom `ARAPlaybackRenderer` instance 
(see the section below on plugin instance roles for information regarding `ARAPlaybackRenderer`. )

<br>
#### ARA Model Objects

To make ARA easier to integrate with existing JUCE code, we've subclassed the C++ classes provided 
in the ARA SDK into counterparts in the `juce` namespace:
- `ARA::PlugIn::Document` ==> `juce::ARADocument`
- `ARA::PlugIn::MusicalContext` ==> `juce::ARAMusicalContext`
- `ARA::PlugIn::RegionSequence` ==> `juce::ARARegionSequence`
- `ARA::PlugIn::AudioSource` ==> `juce::ARAAudioSource`
- `ARA::PlugIn::AudioModification` ==> `juce::ARAAudioModification`
- `ARA::PlugIn::PlaybackRegion` ==> `juce::ARAPlaybackRegion`

These model objects can be subclassed further by overriding the `ARADocumentController::doCreate` 
functions as needed, i.e
```
class MyCustomAudioSource : public juce::ARAAudioSource
{
    using juce::ARAAudioSource::ARAAudioSource;
};

class MyCustomDocumentController : public juce::ARADocumentController
{
    ARA::PlugIn::AudioSource* doCreateAudioSource (ARA::PlugIn::Document* document, ARA::ARAAudioSourceHostRef hostRef) 
    noexcept override
    {
        return new MyCustomAudioSource (static_cast<ARADocument*> (document), hostRef);
    }
};
```

<br>
#### ARA PlugIn Instance Roles

When an ARA plug-in is instantiated by the host it will take on one or more instance roles 
as defined by the ARA API. To represent this concept in JUCE we've created two extension classes:

The `AudioProcessorARAExtension` class, meant to be subclassed by the JUCE plugin's `AudioProcessor`
implementation, allows access to all three plugin instance roles bound to the JUCE plugin instance.
The two renderer roles (`ARAPlaybackRenderer` and `ARAEditorRenderer`) will be used by an `AudioProcessor`
instance, so they've been given similar lifetime management functions:
- `ARAPlaybackRenderer::prepareToPlay` - do any pre-playback preparation
- `ARAPlaybackRenderer::processBlock` - render audio samples
- `ARAPlaybackRenderer::releaseResources` - clean up resources while not playing

An implementation of an `ARAPlaybackRenderer` can be found in the 
[ARA Sample Project PlaybackRenderer class](https://github.com/Celemony/JUCE_ARA/tree/develop/examples/ARA/ARASampleProject/Source/ARASampleProjectPlaybackRenderer.h). 

The `AudioProcessorEditorARAExtension` class, meant to be subclassed by the JUCE plugin's `AudioProcessorEditor`
implementation, allows access to the `ARAEditorView` role and helps the plugin interact with host selection
and UI state. 

Ultimately it's up to the host to decide when and where to instantiate your plugin and what roles its meant
to fulfill. To query whether or not a given plugin instance is meant to fulfill a particular role, we've
given these extension classes the following convenience functions:
```
// if any isX returns false, the corresponding getX will return nullptr
bool AudioProcessorARAExtension::isARAPlaybackRenderer() const noexcept;
bool AudioProcessorARAExtension::getARAPlaybackRenderer() const noexcept;

bool AudioProcessorARAExtension::isARAEditorRenderer() const noexcept;
bool AudioProcessorARAExtension::getARAEditorRenderer() const noexcept;

bool AudioProcessorARAExtension::isARAEditorView() const noexcept;
bool AudioProcessorARAExtension::getARAEditorView() const noexcept;

bool AudioProcessorEditorARAExtension::isARAEditorView() const noexcept;
bool AudioProcessorEditorARAExtension::getARAEditorView() const noexcept;
```
<br>
#### Listeners

To make things feel more "JUCEy", we've given each JUCE model obect a `Listener` base class 
with virtual callbacks that can be overridden to receive notifications related to the ARA model graph and
host rendering / UI state. These callbacks meant to replace the `will/did` functions that would 
be overridden by an `ARA::PlugIn::DocumentController` implementation using the ARA C++ library. 

Listener updates are subscribed to on a per-object basis. For example, if you need to 
keep track of the properties of a particular `ARAPlaybackRegion`, you must subclass 
`ARAPlaybackRegion::Listener` and and add/remove yourself as a listener of that playback region
via `addListener` and `removeListener`. We've also added this `Listener` pattern to the 
`ARAEditorView` instance role to help manage selection and UI state. 

```
class PlaybackRegionManager  : public ARAPlaybackRegion::Listener
{
public:
    PlaybackRegionManager(ARAPlaybackRegion* region)
        : myRegion (region)
    {
        myRegion->addListener (this);
    }
    ~PlaybackRegionManager() 
    {
        myRegion->removeListener (this);
    }

private:
    ARAPlaybackRegion* myRegion;
};
```

See the [ARA Sample Project PlaybackRegionView class](https://github.com/Celemony/JUCE_ARA/tree/develop/examples/ARA/ARASampleProject/Source/PlaybackRegionView.h)
for an example of several `Listener` implementations in action. 

<br>
#### Audio Readers

Reading large buffers of audio samples at will is a key component of the ARA API. Because the
concept of audio readers already exists in JUCE, we've subclassed the existing `juce::AudioFormatReader` 
to read audio samples via ARA in a class called `juce::ARAAudioSourceReader` that allows reading samples
from a single `ARAAudioSource`. We can construct an `ARAAudioSourceReader` via the `ARADocumentController ` 
using its `createAudioSourceReader` function. 

We've also created reader classes that can use an `ARAPlaybackRenderer` instance to read samples as 
if they were being output by the renderer instance. This is useful if you want to deal with playback regions
instead of the original audio source samples. These readers can operate on a distinct group of
`ARAPlaybackRegions` using an `ARAPlaybacRegionReader` as well as an entire `ARARegionSequence` using
`ARARegionSequenceReader`. 

Once created, the our readers can be treated like any other `AudioFormatReader` - the 
[ARA Sample Project PlaybackRegionView class](https://github.com/Celemony/JUCE_ARA/tree/develop/examples/ARA/ARASampleProject/Source/PlaybackRegionView.h)
takes advantage of this by giving a `juce::AudioThubnail` instance an `ARAPlaybackRegionReader` to draw a
visualization of playback region waveform. 

<br>
### Understanding the ARA Sample Project

In addition to the sample plugin provided in the ARA SDK we've created a sample project showcasing the 
ARA additions to the JUCE API. The sample project can be found at 
[JUCE_ARA/examples/ARA/ARASampleProject](https://github.com/Celemony/JUCE_ARA/tree/develop/examples/ARA/ARASampleProject). Below is an example
of the plugin being hosted by Studio One. 

<img src="https://i.imgur.com/gK7GZq8.png"/>

<br>
The sample can be broken into five important classes:

#### `ARASampleProjectDocumentController`

This is the central point of communication between our plugin and the ARA host. A single instance of this 
class will be constructed by the host per project, and it will be used by the host whenever ARA objects and 
plugin instances need to be be constructed. Because only one instance exists per project, 
it's also a good place to store resources that don't need to be duplicated for each plugin instance. 

The host creates our `ARASampleProjectDocumentController` instance using our `doCreateDocumentController` 
override:
```
ARA::PlugIn::DocumentController* ARA::PlugIn::DocumentController::doCreateDocumentController() noexcept
{
    return new ARASampleProjectDocumentController();
}
```

In this case, we're using our document controller to do two important things:
- construct an instance of our ARAPlaybackRenderer class by overriding `doCreatePlaybackRenderer`
```
ARA::PlugIn::PlaybackRenderer* ARASampleProjectDocumentController::doCreatePlaybackRenderer() noexcept
{
    return new ARASampleProjectPlaybackRenderer (this);
}
```
- manage a time slice thread that we'll use to read audio samples, initialized in our constructor
```
ARASampleProjectDocumentController::ARASampleProjectDocumentController() noexcept
    : ARADocumentController(),
      audioSourceReadingThread (String (JucePlugin_Name) + " ARA Sample Reading Thread")
{
    audioSourceReadingThread.startThread();
}
```

<br>
#### `ARASampleProjectPlaybackRenderer`

Our document controller gets used to construct an instance of our `ARASampleProjectPlaybackRenderer` class. 
This class takes on the `ARAPlaybackRenderer` plugin instance role as defined by the ARA SDK, meaning it will
be used to render audio samples by the host during playback in realtime and non-realtime contexts. 

Because an individual plugin instance may or may not be required to fulfill the `ARAPlaybackRenderer` role, 
our `AudioProcessor` must subclass `AudioProcessorARAExtension` and delegate to any renderers bound to it:
```
// our processor subclasses AudioProcessorARAExtension 
class ARASampleProjectAudioProcessor    : public AudioProcessor,
                                          public AudioProcessorARAExtension
```
```
// which we use to determine if we need to delegate to our renderers
void ARASampleProjectAudioProcessor::prepareToPlay (double newSampleRate, int samplesPerBlock)
{
    if (isARAPlaybackRenderer())
        getARAPlaybackRenderer()->prepareToPlay (newSampleRate, getTotalNumOutputChannels(), samplesPerBlock, true);
    if (isARAEditorRenderer())
        getARAEditorRenderer()->prepareToPlay (newSampleRate, getTotalNumOutputChannels(), samplesPerBlock);
}
```
Functionally our renderer does nothing more than render the original audio data, but it does so by reading
the source audio samples from the host via ARA and playing them back using a `juce::AudioFormatReader` 
instance (making it an ARA enabled pass through renderer.) 

To do this, playback renderer overrides all three virtual renderer functions described in the Plugin Instance Role section:
- `ARASampleProjectPlaybackRenderer::prepareToPlay` \- in addition to allocating some temporary buffers, this function constructs an `AudioFormatReader`
instance used to read audio samples from the ARA host. To do this we'll use an `ARAAudioSourceReader` instance, 
though when rendering in realtime we'll wrap that instance in a `BufferingAudioReader` so that we can
read host samples ahead of time on the document controller's time slice thread. 
- `ARASampleProjectPlaybackRenderer::processBlock` \- because each playback renderer instance is assigned specific playback regions that it's responsible
for rendering, the bulk of this code is concerned with determining when and where playback region samples should go 
within incoming audio buffers. Once this is determined we can use our `ARAAudioSourceReader` to 
read samples and render them into the supplied buffer. 
- `ARASampleProjectPlaybackRenderer::releaseResources` \- this function cleans up all reader instance and temporary buffers used for reading audio source samples

<br>
#### `TrackHeaderView`

This view displays the "tracks" (or `ARARegionSequences`) in our ARA host's document. The track color, as
specified by the user inside the host, is represented as a colored rectangle. If a name is provided this is
shown as well. Because this view is closely tied to a particular `ARARegionSequence` instance, it subclasses
`ARARegionSequence::Listener` in order to properly handle region sequence property updates and lifetime. 

```
void TrackHeaderView::didUpdateRegionSequenceProperties (ARARegionSequence* sequence)
{
    repaint();
}

void TrackHeaderView::willDestroyRegionSequence (ARARegionSequence* sequence)
{
    detachFromRegionSequence();
}
```

We also display selection state by subclassing `ARAEditorView::Listener` - if the user selects a particular
track in the host, we visualize this with a yellow border around the track header. 

```
void TrackHeaderView::onNewSelection (const ARA::PlugIn::ViewSelection& currentSelection)
{
    bool isOurRegionSequenceSelected = ARA::contains (currentSelection.getRegionSequences(), regionSequence);
    if (isOurRegionSequenceSelected != isSelected)
    {
        isSelected = isOurRegionSequenceSelected;
        repaint();
    }
}
```


<img src="https://i.imgur.com/mouUUXp.gif"/>

<br>
#### `PlaybackRegionView`

The `PlaybackRegionView` class is responsible for visualizing the waveform of a playback region in our
ARA document. Each `PlaybackRegionView` is responsible for drawing a single `ARAPlaybackRegion`, which is done
using a `juce::AudioThumbnail` - we pass the `juce::AudioThumbnail::setReader` function an 
`ARAPlaybackRegionReader` instance tasked with reading the view's playback region and let the thumbnail
do the rest of the work, taking care to draw only the visible portion of the region to avoid reading too
many samples per draw call. 

```
// create a non-realtime playback region reader for our audio thumb
playbackRegionReader = documentView.getARADocumentController()->createPlaybackRegionReader({playbackRegion}, true);
audioThumb.setReader (playbackRegionReader, reinterpret_cast<intptr_t> (playbackRegion));
```
	
Like `ARARegionSequences`, individual `ARAPlaybackRegions` also have a selection state. By subclassing
`ARAEditorView::Listener` we can receive selection notifications and determine whether or not our given
region is selected. The selection state is visualized by a yellow rectangular border around the waveform,
just like the `TrackHeaderView`. 
```
void PlaybackRegionView::onNewSelection (const ARA::PlugIn::ViewSelection& currentSelection)
{
    bool isOurPlaybackRegionSelected = ARA::contains (currentSelection.getPlaybackRegions(), playbackRegion);
    if (isOurPlaybackRegionSelected != isSelected)
    {
        isSelected = isOurPlaybackRegionSelected;
        repaint();
    }
}
```

The regions can also be zoomed horizontally and vertically:

<img src="https://i.imgur.com/G30nSLA.gif"/>

<br>
#### `RulersView`

The `RulersView` draws a representation of the musical grid in our ARA document. We use the first 
`ARAMusicalContext` in the document to extract tempo and bar signature content as well as any info on the
changing chord stucture in the song using content reader classes provided by the ARA SDK:
```
const TempoContentReader tempoReader (musicalContext);
const BarSignaturesContentReader barSignaturesReader (musicalContext);
const ChordsContentReader chordsReader (musicalContext);
```
To begin we draw our seconds ruler representing "time on the clock" - we draw a tick mark at each second,
emphasizing every 10th second with a longer tick mark and every minute with a bolder tick mark. 

Next comes our musical timing grid - using convenience classes provided by the ARA C++ Library we can draw
tick marks at each  musical beat along the ARA document's timeline, representing downbeats with a thicker mark. 

<img src="https://i.imgur.com/6uUq5QH.gif"/>

Finally we draw our chord ruler, representing the chord structure of the ARA document. In a host like
Studio One you can define a changing chord progression for your song mapped to musical beats. This ruler
visualizes those chords above the musical timing grid as colored rectangles showing the name of the chord. 

The RulersView also displays the host's current playhead position as a vertical line - by clicking on the grid
of the RulersView you can instruct the host to modify its current play position - double clicking the grid will
instruct the host to start playback. 

<img src="https://i.imgur.com/cVNRNfj.gif"/>

<!-- 
TODO JUCE_ARA
These views are mostly concerned with UI organization and placement, they may not
be worth getting in to in the README. 
#### DocumentView

#### RegionSequenceView
-->

<br>

# The JUCE 5 Library

**BY DOWNLOADING, INSTALLING OR USING ANY PART OF THE JUCE LIBRARY, YOU AGREE
TO THE [JUCE 5 END-USER LICENSE AGREEMENT](https://www.juce.com/juce-5-licence)
AND [JUCE 5 PRIVACY POLICY](https://www.juce.com/juce-5-privacy-policy), WHICH
ARE BINDING AGREEMENTS BETWEEN YOU AND ROLI, LTD. IF YOU DO NOT AGREE TO THE
TERMS, DO NOT USE THE JUCE LIBRARY.**

JUCE is an all-encompassing C++ framework for developing cross-platform
software. JUCE is used by hundreds of companies to develop powerful,
cross-platform audio, interactive, embedded or graphic applications.

We now have tier-leveled license terms for JUCE 5, with different terms for
each available license: JUCE Personal (for developers or startup businesses
with revenue under 50K USD "Revenue Limit"; free), JUCE Indie (for small
businesses with under 200K Revenue Limit; $35/month), JUCE Pro (no Revenue
Limit; $65/month), and JUCE Educational (no Revenue Limit; free for bona fide
educational institutes). All licenses allow you to commercially release
applications so long as you do not exceed the Revenue Limit and pay applicable
Fees. Once your business hits the Revenue Limit for your JUCE license, you will
either have to upgrade your JUCE license or release your Applications under the
[GNU General Public License v.3](https://www.gnu.org/licenses/gpl-3.0.en.html),
which means, among other things, that your code can be freely copied and
distributed.

You agree to give notice to the end-users of your Applications that we may
track the IP addresses associated with their use of the Applications using JUCE
solely for our internal purposes in providing JUCE, unless you are a paying
JUCE customer and opt-out of such tracking. You agree to fully comply with all
laws, including relating to the collection of information from children and the
[Childrenâ€™s Online Privacy Protection Act
(COPPA)](https://www.ftc.gov/enforcement/rules/rulemaking-regulatory-reform-proceedings/childrens-online-privacy-protection-rule).

JUCE IS PROVIDED "AS IS" WITHOUT ANY WARRANTY, AND ALL WARRANTIES, WHETHER
EXPRESSED OR IMPLIED, INCLUDING WARRANTY OF MERCHANTABILITY AND FITNESS FOR A
PARTICULAR PURPOSE, ARE DISCLAIMED.

The juce_audio_basics, juce_audio_devices, juce_blocks_basics, juce_core and
juce_events modules are permissively licensed under the terms of the [ISC
license](http://www.isc.org/downloads/software-support-policy/isc-license).

For more information, visit the website:
[www.juce.com](https://www.juce.com)

FULL JUCE TERMS:
- [JUCE 5 END-USER LICENSE AGREEMENT](https://www.juce.com/juce-5-licence)
- [JUCE 5 PRIVACY POLICY](https://www.juce.com/juce-5-privacy-policy)
![alt text](https://d30pueezughrda.cloudfront.net/juce/JUCE_banner.png "JUCE")

JUCE is an open-source cross-platform C++ application framework used for rapidly
developing high quality desktop and mobile applications, including VST, AU (and AUv3),
RTAS and AAX audio plug-ins. JUCE can be easily integrated with existing projects or can
be used as a project generation tool via the [Projucer](https://juce.com/discover/projucer),
which supports exporting projects for Xcode (macOS and iOS), Visual Studio, Android Studio,
Code::Blocks, CLion and Linux Makefiles as well as containing a source code editor and
live-coding engine which can be used for rapid prototyping.

## Getting Started
The JUCE repository contains a [master](https://github.com/weareroli/JUCE/tree/master)
and [develop](https://github.com/weareroli/JUCE/tree/develop) branch. The develop branch
contains the latest bugfixes and features and is periodically merged into the master
branch in stable [tagged releases](https://github.com/WeAreROLI/JUCE/releases)
(the latest release containing pre-built binaries can be also downloaded from the
[JUCE website](https://shop.juce.com/get-juce)).

The repository doesn't contain a pre-built Projucer so you will need to build it
for your platform - Xcode, Visual Studio and Linux Makefile projects are located in
[extras/Projucer/Builds](/extras/Projucer/Builds)
(the minumum system requirements are listed in the __System Requirements__ section below).
The Projucer can then be used to create new JUCE projects, view tutorials and run examples.
It is also possible to include the JUCE modules source code in an existing project directly,
or build them into a static or dynamic library which can be linked into a project.

For further help getting started, please refer to the JUCE
[documentation](https://juce.com/learn/documentation) and
[tutorials](https://juce.com/learn/tutorials).

## System Requirements
#### Building JUCE Projects
- __macOS__: macOS 10.11 and Xcode 7.3.1
- __Windows__: Windows 8.1 and Visual Studio 2013 64-bit
- __Linux__: GCC 4.8

#### Minimum Deployment Targets
- __macOS__: macOS 10.7
- __Windows__: Windows Vista
- __Linux__: Mainstream Linux distributions

## Contributing
For bug reports and features requests, please visit the [JUCE Forum](https://forum.juce.com/) -
the JUCE developers are active there and will read every post and respond accordingly. When
submitting a bug report, please ensure that it follows the
[issue template](/.github/ISSUE_TEMPLATE.txt).
We don't accept third party GitHub pull requests directly due to copyright restrictions
but if you would like to contribute any changes please contact us.

## License
The core JUCE modules (juce_audio_basics, juce_audio_devices, juce_blocks_basics, juce_core
and juce_events) are permissively licensed under the terms of the
[ISC license](http://www.isc.org/downloads/software-support-policy/isc-license/).
Other modules are covered by a
[GPL/Commercial license](https://www.gnu.org/licenses/gpl-3.0.en.html).

There are multiple commercial licensing tiers for JUCE 5, with different terms for each:
- JUCE Personal (developers or startup businesses with revenue under 50K USD) - free
- JUCE Indie (small businesses with revenue under 200K USD) - $35/month
- JUCE Pro (no revenue limit) - $65/month
- JUCE Eductational (no revenue limit) - free for bona fide educational institutes

For full terms see [LICENSE.md](LICENSE.md).
